setcfg main_font "Arial-11"       ;# alternative: Palatino-11, Arial-11
setcfg posbox_font Arial-8

setcfg focus_follows_mouse 1

setcfg editor_bg_color 255
setcfg editor_fg_color 16777215
setcfg posbox_border_color 0
setcfg posbox_bg_color 15654274
setcfg posbox_fg_color 0

bindkey Ctrl-Space mark

bindkey Ctrl-c {cb copy}
bindkey Ctrl-v {cb paste}
bindkey Ctrl-x {cb cut}
bindkey Ctrl-y {cb ppaste}

bindkey Ctrl-u undo

bindkey Ctrl-s save
bindkey Ctrl-b bufman

bindkey Ctrl-f search

bindkey Ctrl-a gohome
bindkey Ctrl-e {go $}
bindkey Ctrl-Left {move prev wnwa}
bindkey Ctrl-Right {move next wnwa}
bindkey Ctrl-Home {go 0}
bindkey Ctrl-End {go -1}

bindkey Ctrl-Backspace {move prev wnwa del}

proc kill_line {} {
   go :0
   mark
   go $
   #TODO: here we should check if we moved and if we didn't just delete one character
   cb cut
}

bindkey Ctrl-k kill_line

proc shell_perform_redirection {redirection} {
   set redirected_descriptor [dict get $redirection redirected_descriptor]
   set open_direction [dict get $redirection open_direction]
   set target [dict get $redirection target]
      
   switch -exact $open_direction {
      ">" {
         if {$redirected_descriptor eq ""} {set redirected_descriptor 1}
         #puts "Sending $redirected_descriptor to $target"
         set fd [fdopen -wronly $target]
         fddup2 $fd $redirected_descriptor
         fdclose $fd
      }
      ">&" {
         if {$redirected_descriptor eq ""} {set redirected_descriptor 1}
         fddup2 $target $redirected_descriptor
      }
      "<" {
         if {$redirected_descriptor eq ""} {set redirected_descriptor 0}
         set fd [fdopen -rdonly $target]
         fddup2 $fd $redirected_descriptor
         fdclose $fd
      }
      "<&" {
         if {$redirected_descriptor eq ""} {set redirected_descriptor 0}
         fddup2 $target $redirected_descriptor
      }
      ">>" {
         if {$redirected_descriptor eq ""} {set redirected_descriptor 1}
         set fd [fdopen -wronly -append $target]
         fddup2 $fd $redirected_descriptor
         fdclose $fd
      }
   }
}

proc shell_eat {args i specialVarName normalVarName} {
   set special {}
   set normal {}
   
   for {} {$i < [llength $args]} {incr i} {
      set cur [lindex $args $i]
      if {$cur eq "&&"} { break }
      if {$cur eq "||"} { break }
      set isspecial [regexp {^([0-9]*)(>|>&|<&|<|>>)(.*)$} $cur -> redirected_descriptor open_direction target]
      if {$isspecial} {
         lappend special [dict create redirected_descriptor $redirected_descriptor open_direction $open_direction target $target]
      } else {
         lappend normal $cur
      }
   }
   
   upvar $specialVarName specialVar
   upvar $normalVarName normalVar
   set specialVar $special
   set normalVar $normal
      
   return $i
}

proc shell_child_code {special normal} {
   # child code, make redirects and exec
   
   #puts "message from child code"
   
   for {set i 0} {$i < [llength $special]} {incr i} {
      shell_perform_redirection [lindex $special $i]
   }
   
   #puts "Executing $normal"
   posixexec {*}$normal
   
   posixexit -1
}

proc shell {args} {
   global backgrounded
   if {!$backgrounded} {
      error "shell called on a non backgrounded interpreter"   
   }
   
   set i 0
 
   while {$i < [llength $args]} {
      set i [shell_eat $args $i special normal]
   
      puts "New value of i: $i"
   
      set pid [posixfork]
      if {$pid < 0} {
         error "fork failed in 'shell'"
      }
      
      if {$pid == 0} {
         shell_child_code $special $normal
      }
   
      # parent code, wait and exit
         
      if {$i >= [llength $args]} {
         #puts "waiting for $pid"
         set r [posixwaitpid $pid]
         puts "wait ended $r"
         posixexit [lindex $r 1]
      }
      
      switch -exact [lindex $args $i] {
         "&&" {
            puts "Processing AND $pid"
            set r [posixwaitpid $pid]
            puts "Child returned [lindex $r 1]"
            if {[lindex $r 1] != 0} {
               # can not continue because last execution failed
               posixexit [lindex $r 1]
            }
         }
         "||" {
            set r [posixwaitpid $pid]
            if {[lindex $r 1] == 0} {
               # should not continue because last execution succeeded
               posixexit [lindex $r 1]
            }
         }
         "|" {
            #TODO: implement piping
         }
      }
      
      # skipping separator
      incr i
   }
}
