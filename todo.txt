- bufman doesn't display a window, it switches the current editor to the +bufman+ special buffer (that has special keybindings)
  - implement buffer command (except keyprocessor)
  - implement bufman visualization
  - implement "kill buffer" with specifier
  - implement go with buffer specifier
  - implement keyprocessor
  - remove old implementation

- right click on a binary file copies it on the command line (in brackets)
- splitting of columns, frames (instead of just adding at the end)
- replace tcl regex engine with TRE
- interface tabs
- TAGS files
- options for tab character visualization
- macros
- gdb integration
- fix bad rendering perfomance by killing cairo
- debugger integration (just displaying currently executed line)
- selection should copy selected text on past not on selection, for better efficiency (selection slowdown is noticeable on mouse selection)
- extend regular expressions in 's' to be lexically aware
- disable selection when another application becomes the owner of the primary selection buffer
- word movement, word selection and tokenization should be tied to syntax analysis
- change perror to show error windows
- implement | command that filters selected content through external command
- make easy way to reindent though external filter
- cmdcompl shoul build the list of internal commands dynamically
- command line autocompletion shouldn't include commands unless it's the first word con the command line
- implement command to create a scratch buffer
- fix mark words when used with cursor keys
- implement stayoncmd flag for buffers
- implement lockcmd command that changes the command line of a buffer to always send a specific command
- implement ability to switch a buffer's main font
- implement +bg+ buffer setup hook, set as defaults: stayoncmd, disable horzontal scrollbar, switch font to monospaced
- Ctrl-o move to next editor (keep a stack of editors like windows' windows)
- command to change buffer font to fixed width (start +bg buffers on fixed width by default)
- ansi sequences processing
- clear buffer command
- minimum size of an editor should be its tag alone, and there should be a simple way to minimize an editor
- 's' command: support normal pcre flags
- sort buffer menu by buffer name?
- appending to a buffer that was never displayed doesn't work (for some reason), tons of valgrind exceptions are generated. There is a valid use case for starting commands on an invisible buffer
- persistence of history
- ability to persist the status of a window
- auto-reloading buffers when there is no change and the file on disk was changed
- left+middle -> cut
- move mouse cursor when searching with mouse
- use an editor for the command line
- disabling soft word wrap
- clang syntax highlighting
- elastic tabs

https://github.com/agl/critbit

Prototype for bufman in tcl:

proc bufman() {
	# create a new buffer called +bufman+
	# bufman variable will contain the string "@b<buffer-id>" where <buffer-id> is the id of the newly created buffer
	set bufman [buffer make "+bufman+"]

	buffer propset $bufman bufman-previous-buffer [buffer current]

	# switch the current editor to the new buffer, requires implementing 'go' to a buffer-id (in the form "@b<buffer-id>")
	# and the argument -here for 'go' that skips the selection window and just uses the current editor
	go -here $bufman

	c "ID\tName\tPath\n"

	# buffer ls returns the current list of buffers
	foreach buf [buffer ls] {
		# gets informations about a buffer id
		set bufinfo [buffer info $buf]

		c [dict get $bufinfo id]
		c "\t"
		c [dict get $bufinfo name]
		c "\t"
		c [dict get $bufinfo path]
		c "\n"
	}

	# Makes bufman special, now keypresses will be processed by a special function instead of the normal editor
	# this lets us make this buffer a list
	buffer setkeyprocessor $bufman bufman_keyprocessor
}

proc bufman_keyprocessor($key) {
	if {$key eq "Escape"} {
		go -here [buffer propget [buffer current] bufman-previous-buffer]
		return
	}

	if {$key eq "Return"} {
		# gets current line
		mark transient
		mark lines
		set tobuffer [lindex [split [mark get] " "] 0]
		mark stop

		set bufman [buffer current]
		go -here $tobuffer

		if { [buffer current] ne $bufman } {
			# go succeded, kill current buffer -- this needs to be implemented too
			kill buffer $bufman
		}

		return
	}
}